// scripts/test-web3-integration.js
const hre = require("hardhat");

async function main() {
  console.log("🧪 Testing DeFi Watchdog Web3 Integration...");
  
  const contractAddress = process.env.NEXT_PUBLIC_AUDIT_NFT_CONTRACT || 
                         '0x46E086aac77023AD6E1EA65cC23A6f0Fa91Cf118';
  
  console.log("📍 Contract Address:", contractAddress);
  console.log("🌐 Network:", hre.network.name);
  
  // Get signers
  const signers = await hre.ethers.getSigners();
  const deployer = signers[0];
  const user1 = signers.length > 1 ? signers[1] : deployer; // Use deployer as fallback if only one signer
  
  console.log("👤 Deployer:", deployer.address);
  console.log("👤 Test User:", user1.address);
  
  // Get contract instance
  const DeFiWatchdogAuditNFT = await hre.ethers.getContractFactory("DeFiWatchdogAuditNFT");
  const contract = DeFiWatchdogAuditNFT.attach(contractAddress);
  
  try {
    console.log("\n🔍 Testing Contract Functions...");
    
    // Test 1: Check contract state
    console.log("1️⃣ Testing contract state...");
    const name = await contract.name();
    const symbol = await contract.symbol();
    const staticPrice = await contract.STATIC_AUDIT_PRICE();
    const aiPrice = await contract.AI_AUDIT_PRICE();
    
    console.log(`   ✅ Name: ${name}`);
    console.log(`   ✅ Symbol: ${symbol}`);
    console.log(`   ✅ Static Price: ${hre.ethers.utils.formatEther(staticPrice)} ETH`);
    console.log(`   ✅ AI Price: ${hre.ethers.utils.formatEther(aiPrice)} ETH`);
    
    // Test 2: Test static audit minting (free)
    console.log("\n2️⃣ Testing static audit minting...");
    
    // Use a properly formatted address - let's use the contract's own address as test
    const testContractAddress = contractAddress.toLowerCase();
    const contractName = "Test Contract";
    const ipfsHash = "QmTestHash123456789"; // Mock IPFS hash
    const securityScore = 85;
    const riskLevel = 0; // LOW = 0
    
    // Check if certificate already exists
    const alreadyExists = await contract.hasCertificate(testContractAddress);
    console.log(`   📋 Certificate exists: ${alreadyExists}`);
    
    if (!alreadyExists) {
      try {
        console.log("   🆓 Minting static audit certificate...");
        
        const tx = await contract.connect(user1).mintStaticAuditReport(
          testContractAddress,
          contractName, 
          ipfsHash,
          securityScore,
          riskLevel
        );
        
        console.log(`   📋 Transaction sent: ${tx.hash}`);
        
        const receipt = await tx.wait();
        console.log(`   ✅ Transaction confirmed in block ${receipt.blockNumber}`);
        console.log(`   ⛽ Gas used: ${receipt.gasUsed.toString()}`);
        
        // Extract token ID from events
        let tokenId = null;
        for (const log of receipt.logs) {
          try {
            const parsed = contract.interface.parseLog(log);
            if (parsed.name === 'AuditReportMinted') {
              tokenId = parsed.args.tokenId.toString();
              console.log(`   🎫 Token ID: ${tokenId}`);
              break;
            }
          } catch (e) {
            // Skip unparseable logs
          }
        }
        
        if (tokenId) {
          // Test getting audit report
          console.log("   📊 Fetching audit report...");
          const [
            reportContractAddress,
            auditor,
            auditType,
            reportRiskLevel,
            reportSecurityScore,
            reportIpfsHash,
            reportContractName,
            timestamp,
            paidAmount
          ] = await contract.getAuditReport(tokenId);
          
          console.log(`   ✅ Report Contract: ${reportContractAddress}`);
          console.log(`   ✅ Auditor: ${auditor}`);
          console.log(`   ✅ Audit Type: ${auditType} (0=STATIC, 1=AI)`);
          console.log(`   ✅ Risk Level: ${reportRiskLevel} (0=LOW, 1=MEDIUM, 2=HIGH, 3=CRITICAL)`);
          console.log(`   ✅ Security Score: ${reportSecurityScore}`);
          console.log(`   ✅ IPFS Hash: ${reportIpfsHash}`);
          console.log(`   ✅ Contract Name: ${reportContractName}`);
          console.log(`   ✅ Paid Amount: ${hre.ethers.utils.formatEther(paidAmount)} ETH`);
        }
        
      } catch (error) {
        if (error.message.includes("Certificate already exists")) {
          console.log("   ⚠️ Certificate already exists for this contract");
        } else if (error.message.includes("Address is not a contract")) {
          console.log("   ⚠️ Test address is not a contract (expected for testing)");
        } else {
          throw error;
        }
      }
    }
    
    // Test 3: Check user audits
    console.log("\n3️⃣ Testing user audit history...");
    const userAudits = await contract.getUserAudits(user1.address);
    console.log(`   📋 User has ${userAudits.length} audit(s)`);
    
    // Test 4: Check contract audits
    console.log("\n4️⃣ Testing contract audit history...");
    const contractAudits = await contract.getContractAudits(testContractAddress);
    console.log(`   📋 Contract has ${contractAudits.length} audit(s)`);
    
    // Test 5: Get statistics
    console.log("\n5️⃣ Testing statistics...");
    const totalAudits = await contract.getTotalAudits();
    const [staticCount, aiCount] = await contract.getAuditTypeStats();
    const [lowCount, mediumCount, highCount, criticalCount] = await contract.getRiskLevelStats();
    
    console.log(`   📊 Total Audits: ${totalAudits}`);
    console.log(`   📊 Static Audits: ${staticCount}`);
    console.log(`   📊 AI Audits: ${aiCount}`);
    console.log(`   📊 Risk Levels - Low: ${lowCount}, Medium: ${mediumCount}, High: ${highCount}, Critical: ${criticalCount}`);
    
    // Test 6: Test AI audit minting (paid) - only if user has enough balance
    console.log("\n6️⃣ Testing AI audit minting...");
    const userBalance = await user1.getBalance();
    const requiredBalance = hre.ethers.utils.parseEther("0.01"); // 0.003 + gas
    
    if (userBalance.gt(requiredBalance)) {
      // Use deployer's address as test contract for AI audit
      const testContractAddress2 = deployer.address.toLowerCase();
      const alreadyExists2 = await contract.hasCertificate(testContractAddress2);
      
      if (!alreadyExists2) {
        try {
          console.log("   💰 Testing AI audit (paid)...");
          
          const tx = await contract.connect(user1).mintAIAuditReport(
            testContractAddress2,
            "Test AI Contract",
            "QmTestAIHash123456789",
            75,
            1, // MEDIUM = 1
            { value: hre.ethers.utils.parseEther("0.003") }
          );
          
          console.log(`   📋 AI audit transaction sent: ${tx.hash}`);
          
          const receipt = await tx.wait();
          console.log(`   ✅ AI audit confirmed in block ${receipt.blockNumber}`);
          console.log(`   ⛽ Gas used: ${receipt.gasUsed.toString()}`);
          
        } catch (error) {
          if (error.message.includes("Address is not a contract")) {
            console.log("   ⚠️ Test address is not a contract (expected for testing)");
          } else {
            console.log(`   ❌ AI audit test failed: ${error.message}`);
          }
        }
      } else {
        console.log("   ⚠️ AI audit certificate already exists for test contract");
      }
    } else {
      console.log(`   ⚠️ Insufficient balance for AI audit test (need 0.01 ETH, have ${hre.ethers.utils.formatEther(userBalance)} ETH)`);
    }
    
    console.log("\n✅ Web3 Integration Test Complete!");
    console.log("🎯 All functions are working correctly");
    
  } catch (error) {
    console.error("❌ Web3 integration test failed:", error.message);
    console.error("Stack trace:", error.stack);
    process.exit(1);
  }
}

main()
  .then(() => {
    console.log("\n🎉 All tests passed successfully!");
    process.exit(0);
  })
  .catch((error) => {
    console.error("❌ Test suite failed:", error);
    process.exit(1);
  });
