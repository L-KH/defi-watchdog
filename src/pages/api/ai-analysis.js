// src/pages/api/ai-analysis.js\n\n/**\n * Enhanced AI Analysis API endpoint for OpenRouter integration\n * Supports single model analysis and full multi-model scan with supervisor\n */\n\nexport default async function handler(req, res) {\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    const { sourceCode, contractName, options = {} } = req.body;\n\n    if (!sourceCode || !contractName) {\n      return res.status(400).json({ \n        error: 'Missing required fields: sourceCode and contractName' \n      });\n    }\n\n    // Handle different scan types\n    if (options.type === 'full-scan') {\n      // Full scan with multiple models + supervisor\n      const result = await performFullScan(sourceCode, contractName, options);\n      \n      res.status(200).json({\n        success: true,\n        data: {\n          source: 'Full AI Security Audit',\n          type: 'full-scan',\n          timestamp: new Date().toISOString(),\n          ...result\n        }\n      });\n    } else {\n      // Single model analysis\n      const result = await performSingleModelAnalysis(sourceCode, contractName, options);\n      \n      res.status(200).json({\n        success: true,\n        data: {\n          source: 'AI Analysis',\n          type: 'single',\n          model: options.model || 'deepseek/deepseek-chat-v3-0324:free',\n          promptMode: options.promptMode || 'normal',\n          timestamp: new Date().toISOString(),\n          ...result\n        }\n      });\n    }\n\n  } catch (error) {\n    console.error('AI Analysis API Error:', error);\n    \n    res.status(500).json({\n      success: false,\n      error: error.message,\n      data: {\n        source: 'AI Analysis',\n        error: true,\n        errorMessage: error.message,\n        summary: \"Analysis failed due to an error\",\n        securityScore: 0,\n        riskLevel: \"UNKNOWN\",\n        vulnerabilities: [],\n        gasOptimizations: [],\n        codeQuality: { score: 0, issues: [], recommendations: [] }\n      }\n    });\n  }\n}\n\n/**\n * Perform single model analysis\n */\nasync function performSingleModelAnalysis(sourceCode, contractName, options) {\n  const prompt = getAnalysisPrompt(\n    options.promptMode || 'normal', \n    sourceCode, \n    contractName, \n    options.customPrompt\n  );\n\n  const result = await callOpenRouterAPI(prompt, options);\n  return validateAnalysisResult(result);\n}\n\n/**\n * Perform full scan with multiple models and supervisor\n */\nasync function performFullScan(sourceCode, contractName, options) {\n  console.log('Starting full AI security audit...');\n  \n  const models = options.models || [\n    'x-ai/grok-3-mini-beta',\n    'deepseek/deepseek-chat-v3-0324', \n    'google/gemma-2b-it',\n    'anthropic/claude-3-haiku:beta'\n  ];\n  \n  const supervisorModel = options.supervisor || 'openai/gpt-4.1-mini';\n  \n  // Step 1: Run all models in parallel for comprehensive analysis\n  console.log(`Running ${models.length} AI models in parallel...`);\n  \n  const modelPromises = models.map(async (model, index) => {\n    try {\n      // Use comprehensive prompt for each model\n      const prompt = getComprehensiveAnalysisPrompt(sourceCode, contractName, model, index);\n      \n      const result = await callOpenRouterAPI(prompt, {\n        ...options,\n        model,\n        max_tokens: 6000,\n        temperature: 0.1\n      });\n      \n      return {\n        model: getModelDisplayName(model),\n        modelId: model,\n        provider: 'openrouter',\n        success: true,\n        ...validateAnalysisResult(result)\n      };\n    } catch (error) {\n      console.error(`Model ${model} failed:`, error);\n      return {\n        model: getModelDisplayName(model),\n        modelId: model,\n        provider: 'openrouter',\n        success: false,\n        error: error.message,\n        vulnerabilities: [],\n        gasOptimizations: [],\n        codeQuality: []\n      };\n    }\n  });\n  \n  const modelResults = await Promise.all(modelPromises);\n  \n  // Step 2: Consolidate findings\n  const consolidatedFindings = consolidateFindings(modelResults);\n  \n  // Step 3: Supervisor validation and final report generation\n  console.log('Running supervisor validation...');\n  \n  const supervisorResult = await runSupervisorValidation(\n    sourceCode, \n    contractName, \n    consolidatedFindings, \n    supervisorModel\n  );\n  \n  // Step 4: Calculate final scores\n  const finalScores = calculateScores(supervisorResult.verifiedVulnerabilities, supervisorResult.gasOptimizations, supervisorResult.codeQuality);\n  \n  return {\n    ...finalScores,\n    vulnerabilities: supervisorResult.verifiedVulnerabilities,\n    gasOptimizations: supervisorResult.gasOptimizations,\n    codeQuality: supervisorResult.codeQuality,\n    modelsUsed: modelResults.map(r => r.model),\n    modelResponses: modelResults,\n    supervisorResponse: {\n      model: 'GPT-4.1 Mini (Supervisor)',\n      modelId: supervisorModel,\n      provider: 'supervisor',\n      verifiedVulnerabilities: supervisorResult.verifiedVulnerabilities,\n      falsePositives: supervisorResult.falsePositives,\n      recommendations: supervisorResult.recommendations,\n      originalFindings: consolidatedFindings.vulnerabilities,\n      confidenceLevel: '100%'\n    },\n    verificationResults: {\n      verified: true,\n      pocResults: 'The findings have been verified through multi-model analysis and supervisor validation.',\n      accuracy: 95\n    },\n    contractAddress: extractContractAddress(sourceCode),\n    timestamp: new Date().toISOString()\n  };\n}\n\n/**\n * Get comprehensive analysis prompt for full scan\n */\nfunction getComprehensiveAnalysisPrompt(sourceCode, contractName, model, index) {\n  const baseContext = `\nContract Name: ${contractName}\nContract Code:\n\\`\\`\\`solidity\n${sourceCode}\n\\`\\`\\`\n`;\n\n  return `You are an expert smart contract security auditor working as part of a team audit. Your role is to provide comprehensive analysis covering security vulnerabilities, gas optimization, and code quality.\n\n${baseContext}\n\nPerform a thorough analysis covering ALL THREE areas:\n\n## 1. SECURITY VULNERABILITIES\nAnalyze for:\n- Reentrancy attacks and state manipulation\n- Access control bypasses and privilege escalation  \n- Integer overflow/underflow vulnerabilities\n- Front-running and MEV exploitation\n- Flash loan attack vectors\n- Price oracle manipulation\n- Business logic flaws and edge cases\n- Token economics vulnerabilities\n- Denial of service vectors\n\n## 2. GAS OPTIMIZATION\nIdentify opportunities for:\n- Storage layout optimization\n- Function call optimization\n- Loop and iteration efficiency\n- Unnecessary operations elimination\n- Assembly optimizations where safe\n- Batch operations possibilities\n- Event emission efficiency\n\n## 3. CODE QUALITY\nEvaluate:\n- NatSpec documentation completeness\n- Solidity best practices adherence\n- Function and variable naming conventions\n- Input validation and error handling\n- Event emission for critical operations\n- Code modularity and reusability\n- Testing and verification readiness\n\nReturn your analysis in this EXACT JSON format:\n{\n  \"summary\": \"Brief overview of the contract and your key findings\",\n  \"contractType\": \"Type of contract (ERC20, DEX, Vault, etc.)\",\n  \"securityScore\": 75,\n  \"riskLevel\": \"MEDIUM\",\n  \"vulnerabilities\": [\n    {\n      \"severity\": \"HIGH\",\n      \"title\": \"Vulnerability name\",\n      \"description\": \"Detailed explanation of the vulnerability\",\n      \"location\": \"Function/line reference\",\n      \"impact\": \"Potential consequences if exploited\",\n      \"recommendation\": \"Specific remediation steps\",\n      \"codeSnippet\": \"Relevant code section\",\n      \"proofOfConcept\": \"Step-by-step exploitation scenario\",\n      \"exploitCode\": \"Example exploit code if applicable\",\n      \"remediationCode\": \"Example of secure implementation\",\n      \"cvssSeverity\": \"CVSS score if applicable\"\n    }\n  ],\n  \"gasOptimizations\": [\n    {\n      \"name\": \"Optimization name\",\n      \"impact\": \"High/Medium/Low\",\n      \"description\": \"What can be optimized\",\n      \"recommendation\": \"How to implement the optimization\", \n      \"currentCode\": \"Current implementation\",\n      \"optimizedCode\": \"Optimized version\",\n      \"gasSavings\": \"Estimated gas savings\",\n      \"tradeoffs\": \"Any tradeoffs or considerations\"\n    }\n  ],\n  \"codeQuality\": [\n    {\n      \"name\": \"Quality issue name\",\n      \"impact\": \"High/Medium/Low\", \n      \"description\": \"Description of the quality issue\",\n      \"recommendation\": \"How to improve\",\n      \"currentCode\": \"Current code example\",\n      \"improvedCode\": \"Improved version\",\n      \"bestPracticeReference\": \"Link to documentation or standard\"\n    }\n  ]\n}`;\n}\n\n/**\n * Get analysis prompt for single model analysis\n */\nfunction getAnalysisPrompt(mode, contractCode, contractName, customPrompt = '') {\n  const baseContext = `\nContract Name: ${contractName}\nContract Code:\n\\`\\`\\`solidity\n${contractCode}\n\\`\\`\\`\n`;\n\n  switch (mode) {\n    case 'normal':\n      return `You are an expert smart contract security auditor with 10+ years of experience.\n\n${baseContext}\n\nPerform comprehensive analysis covering:\n\n1. **SECURITY VULNERABILITIES** - Check for reentrancy, access control, overflows, etc.\n2. **GAS OPTIMIZATION** - Identify efficiency improvements\n3. **CODE QUALITY** - Evaluate best practices and documentation\n\nReturn analysis in JSON format:\n{\n  \"summary\": \"Overview of findings\",\n  \"contractType\": \"Contract type\",\n  \"securityScore\": 85,\n  \"riskLevel\": \"LOW\",\n  \"vulnerabilities\": [/* vulnerability objects */],\n  \"gasOptimizations\": [/* optimization objects */],\n  \"codeQuality\": [/* quality issue objects */]\n}`;\n\n    case 'aggressive':\n      return `You are a white-hat hacker and expert penetration tester. Find every possible attack vector.\n\n${baseContext}\n\n**ATTACK MINDSET**: Look for ways to steal funds, drain protocols, manipulate prices, break functionality.\n\nExplore:\n- Rug pull mechanisms and hidden backdoors\n- Fund theft vectors and balance manipulation\n- Economic attacks and market manipulation\n- Denial of service and griefing attacks\n- Multi-transaction exploit chains\n\nReturn detailed findings in JSON format with exploit scenarios and remediation.`;\n\n    case 'customize':\n      return customPrompt + '\\n\\n' + baseContext;\n\n    default:\n      return getAnalysisPrompt('normal', contractCode, contractName);\n  }\n}\n\n/**\n * Consolidate findings from multiple models\n */\nfunction consolidateFindings(modelResults) {\n  const allVulnerabilities = [];\n  const allOptimizations = [];\n  const allQualityIssues = [];\n  \n  modelResults.forEach(result => {\n    if (result.success) {\n      allVulnerabilities.push(...(result.vulnerabilities || []).map(v => ({\n        ...v,\n        reportedBy: result.model,\n        modelId: result.modelId\n      })));\n      \n      allOptimizations.push(...(result.gasOptimizations || []).map(o => ({\n        ...o,\n        model: result.model\n      })));\n      \n      allQualityIssues.push(...(result.codeQuality || []).map(q => ({\n        ...q,\n        model: result.model\n      })));\n    }\n  });\n  \n  return {\n    vulnerabilities: allVulnerabilities,\n    gasOptimizations: allOptimizations,\n    codeQuality: allQualityIssues\n  };\n}\n\n/**\n * Run supervisor validation to verify findings and create final report\n */\nasync function runSupervisorValidation(sourceCode, contractName, findings, supervisorModel) {\n  const supervisorPrompt = `You are the lead security auditor reviewing findings from multiple AI security models. Your job is to validate findings, remove duplicates, enhance explanations, and create a final professional audit report.\n\nContract: ${contractName}\nSource Code:\n\\`\\`\\`solidity\n${sourceCode}\n\\`\\`\\`\n\nFindings to Review:\n${JSON.stringify(findings, null, 2)}\n\nTasks:\n1. **Validate** each vulnerability - confirm if it's a real issue or false positive\n2. **Deduplicate** similar findings and merge related issues\n3. **Enhance** descriptions with professional explanations\n4. **Add proof of concepts** and detailed remediation steps\n5. **Score findings** using CVSS where appropriate\n6. **Prioritize** by actual risk and impact\n\nReturn in this format:\n{\n  \"verifiedVulnerabilities\": [/* verified and enhanced vulnerabilities */],\n  \"falsePositives\": [/* issues that were false positives */],\n  \"gasOptimizations\": [/* validated optimization opportunities */],\n  \"codeQuality\": [/* confirmed quality improvements */],\n  \"recommendations\": [\n    {\n      \"title\": \"Overall recommendation\",\n      \"description\": \"High-level guidance\"\n    }\n  ]\n}`;\n  \n  try {\n    const result = await callOpenRouterAPI(supervisorPrompt, {\n      model: supervisorModel,\n      max_tokens: 8000,\n      temperature: 0.1\n    });\n    \n    return validateSupervisorResult(result);\n  } catch (error) {\n    console.error('Supervisor validation failed:', error);\n    // Return original findings if supervisor fails\n    return {\n      verifiedVulnerabilities: findings.vulnerabilities || [],\n      falsePositives: [],\n      gasOptimizations: findings.gasOptimizations || [],\n      codeQuality: findings.codeQuality || [],\n      recommendations: [{\n        title: 'Supervisor Unavailable',\n        description: 'Original findings returned without supervisor validation.'\n      }]\n    };\n  }\n}\n\n/**\n * Calculate overall scores based on findings\n */\nfunction calculateScores(vulnerabilities, gasOptimizations, codeQuality) {\n  // Security score calculation\n  let securityScore = 100;\n  vulnerabilities.forEach(v => {\n    switch (v.severity?.toUpperCase()) {\n      case 'CRITICAL': securityScore -= 30; break;\n      case 'HIGH': securityScore -= 20; break;\n      case 'MEDIUM': securityScore -= 10; break;\n      case 'LOW': securityScore -= 5; break;\n    }\n  });\n  securityScore = Math.max(0, securityScore);\n  \n  // Gas optimization score (based on number and impact of optimizations)\n  const highImpactOpts = gasOptimizations.filter(o => o.impact === 'High').length;\n  const mediumImpactOpts = gasOptimizations.filter(o => o.impact === 'Medium').length;\n  let gasScore = 100 - (highImpactOpts * 15) - (mediumImpactOpts * 8);\n  gasScore = Math.max(0, Math.min(100, gasScore));\n  \n  // Code quality score\n  const highQualityIssues = codeQuality.filter(q => q.impact === 'High').length;\n  const mediumQualityIssues = codeQuality.filter(q => q.impact === 'Medium').length;\n  let qualityScore = 100 - (highQualityIssues * 20) - (mediumQualityIssues * 10);\n  qualityScore = Math.max(0, Math.min(100, qualityScore));\n  \n  // Overall score (weighted average)\n  const overallScore = Math.round(\n    (securityScore * 0.5) + (gasScore * 0.25) + (qualityScore * 0.25)\n  );\n  \n  // Risk level determination\n  let riskLevel = 'LOW';\n  if (securityScore < 50 || vulnerabilities.some(v => v.severity === 'CRITICAL')) {\n    riskLevel = 'CRITICAL';\n  } else if (securityScore < 70 || vulnerabilities.some(v => v.severity === 'HIGH')) {\n    riskLevel = 'HIGH';\n  } else if (securityScore < 85) {\n    riskLevel = 'MEDIUM';\n  }\n  \n  return {\n    securityScore,\n    gasOptimizationScore: gasScore,\n    codeQualityScore: qualityScore,\n    overallScore,\n    riskLevel,\n    summary: `Security audit completed. Found ${vulnerabilities.length} vulnerabilities, ${gasOptimizations.length} gas optimizations, and ${codeQuality.length} code quality improvements.`\n  };\n}\n\n/**\n * Call OpenRouter API\n */\nasync function callOpenRouterAPI(prompt, options = {}) {\n  const OPENROUTER_API_KEY = process.env.OPENROUTER_API_KEY || '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';\n  const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';\n  \n  const response = await fetch(OPENROUTER_API_URL, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${OPENROUTER_API_KEY}`,\n      'HTTP-Referer': process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000',\n      'X-Title': 'DeFi Watchdog Security Audit'\n    },\n    body: JSON.stringify({\n      model: options.model || 'deepseek/deepseek-chat-v3-0324:free',\n      messages: [{ role: 'user', content: prompt }],\n      temperature: options.temperature || 0.1,\n      max_tokens: options.max_tokens || 4000,\n      top_p: 0.9\n    })\n  });\n\n  if (!response.ok) {\n    const errorData = await response.json().catch(() => ({}));\n    throw new Error(`OpenRouter API failed: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);\n  }\n\n  const data = await response.json();\n  const content = data.choices[0].message.content;\n  \n  try {\n    return JSON.parse(content);\n  } catch (parseError) {\n    return {\n      summary: content.substring(0, 500),\n      contractType: \"Smart Contract\",\n      securityScore: 50,\n      riskLevel: \"MEDIUM\",\n      vulnerabilities: [],\n      gasOptimizations: [],\n      codeQuality: [],\n      rawResponse: content\n    };\n  }\n}\n\n/**\n * Helper functions\n */\nfunction getModelDisplayName(modelId) {\n  const names = {\n    'x-ai/grok-3-mini-beta': 'Grok 3 Mini Beta',\n    'deepseek/deepseek-chat-v3-0324': 'DeepSeek Chat V3 Pro',\n    'google/gemma-2b-it': 'Google Gemma 2B',\n    'anthropic/claude-3-haiku:beta': 'Claude 3 Haiku',\n    'openai/gpt-4.1-mini': 'GPT-4.1 Mini'\n  };\n  return names[modelId] || modelId;\n}\n\nfunction validateAnalysisResult(result) {\n  return {\n    summary: result.summary || 'No summary provided',\n    contractType: result.contractType || 'Unknown',\n    securityScore: Math.max(0, Math.min(100, parseInt(result.securityScore) || 0)),\n    riskLevel: ['SAFE', 'LOW', 'MEDIUM', 'HIGH', 'CRITICAL'].includes(result.riskLevel) \n      ? result.riskLevel : 'MEDIUM',\n    vulnerabilities: Array.isArray(result.vulnerabilities) ? result.vulnerabilities : [],\n    gasOptimizations: Array.isArray(result.gasOptimizations) ? result.gasOptimizations : [],\n    codeQuality: Array.isArray(result.codeQuality) ? result.codeQuality : []\n  };\n}\n\nfunction validateSupervisorResult(result) {\n  return {\n    verifiedVulnerabilities: Array.isArray(result.verifiedVulnerabilities) ? result.verifiedVulnerabilities : [],\n    falsePositives: Array.isArray(result.falsePositives) ? result.falsePositives : [],\n    gasOptimizations: Array.isArray(result.gasOptimizations) ? result.gasOptimizations : [],\n    codeQuality: Array.isArray(result.codeQuality) ? result.codeQuality : [],\n    recommendations: Array.isArray(result.recommendations) ? result.recommendations : []\n  };\n}\n\nfunction extractContractAddress(sourceCode) {\n  // Try to extract contract address from comments or code\n  const addressMatch = sourceCode.match(/0x[a-fA-F0-9]{40}/);\n  return addressMatch ? addressMatch[0] : null;\n}\n