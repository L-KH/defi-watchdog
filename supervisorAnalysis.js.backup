// Enhanced Supervisor Analysis System for DeFi Watchdog
// This implements a multi-tiered AI analysis with supervisor verification

/**
 * Supervisor Analysis System
 * 
 * Architecture:
 * 1. Multiple AI models analyze contract in parallel
 * 2. Each model provides independent assessment  
 * 3. Supervisor AI reviews all findings and creates consolidated report
 * 4. Conflict resolution and consensus building
 * 5. Final verification and scoring
 */

import { callOpenRouterAPI } from './aiAnalysis.js';

/**
 * Enhanced Premium Analysis with Supervisor
 */
export async function runSupervisedPremiumAnalysis(sourceCode, contractName, options = {}) {
  console.log('🎯 Starting Supervised Premium Analysis...');
  
  const startTime = Date.now();
  
  try {
    // Phase 1: Parallel AI Analysis
    const analysisResults = await runParallelAnalysis(sourceCode, contractName, options);
    
    // Phase 2: Supervisor Review and Consolidation
    const supervisorResult = await runSupervisorReview(analysisResults, sourceCode, contractName);
    
    // Phase 3: Final Report Generation
    const finalReport = generateFinalReport(analysisResults, supervisorResult, contractName);
    
    return {
      success: true,
      type: 'supervised-premium',
      contractName: contractName,
      analysisTime: Date.now() - startTime,
      analysis: finalReport,
      metadata: {
        modelsUsed: analysisResults.successfulModels,
        supervisorModel: supervisorResult.supervisorModel,
        consensusScore: supervisorResult.consensusScore,
        conflictsResolved: supervisorResult.conflictsResolved,
        totalFindings: finalReport.keyFindings.length,
        verificationLevel: 'SUPERVISOR_VERIFIED'
      },
      timestamp: new Date().toISOString()
    };
    
  } catch (error) {
    console.error('❌ Supervised analysis failed:', error);
    throw new Error(`Supervised premium analysis failed: ${error.message}`);
  }
}

/**
 * Phase 1: Run multiple AI models in parallel with specialized prompts
 */
async function runParallelAnalysis(sourceCode, contractName, options) {
  const models = [
    {
      id: 'deepseek/deepseek-chat-v3-0324:free',
      name: 'DeepSeek Chat V3',
      specialty: 'security-focused',
      prompt: getSpecializedPrompt('security')
    },
    {
      id: 'google/gemma-2-9b-it:free', 
      name: 'Google Gemma 2 9B',
      specialty: 'gas-optimization',
      prompt: getSpecializedPrompt('gas')
    },
    {
      id: 'huggingfaceh4/zephyr-7b-beta:free',
      name: 'Zephyr 7B Beta', 
      specialty: 'code-quality',
      prompt: getSpecializedPrompt('quality')
    },
    {
      id: 'openchat/openchat-7b:free',
      name: 'OpenChat 7B',
      specialty: 'defi-specific',
      prompt: getSpecializedPrompt('defi')
    }
  ];
  
  console.log(`🤖 Running parallel analysis with ${models.length} specialized AI models...`);
  
  // Execute all models in parallel
  const analysisPromises = models.map(async (model, index) => {
    try {
      console.log(`🔄 [${index + 1}/${models.length}] Starting ${model.name} (${model.specialty})...`);
      
      const result = await callOpenRouterAPI({
        model: model.id,
        prompt: model.prompt,
        sourceCode: sourceCode,
        contractName: contractName,
        maxTokens: 3000,
        temperature: 0.1
      });
      
      console.log(`✅ [${index + 1}/${models.length}] ${model.name} completed successfully`);
      
      return {
        modelId: model.id,
        modelName: model.name,
        specialty: model.specialty,
        result: result,
        success: !result.error,
        analysisTime: Date.now()
      };
      
    } catch (error) {
      console.warn(`⚠️ [${index + 1}/${models.length}] ${model.name} failed:`, error.message);
      
      return {
        modelId: model.id,
        modelName: model.name,
        specialty: model.specialty,
        error: error.message,
        success: false
      };
    }
  });
  
  const results = await Promise.all(analysisPromises);
  const successfulResults = results.filter(r => r.success);
  const failedResults = results.filter(r => !r.success);
  
  console.log(`📊 Analysis completed: ${successfulResults.length}/${models.length} models successful`);
  
  if (successfulResults.length === 0) {
    throw new Error('All AI models failed to analyze the contract');
  }
  
  return {
    allResults: results,
    successfulResults: successfulResults,
    failedResults: failedResults,
    successfulModels: successfulResults.map(r => r.modelName),
    successRate: successfulResults.length / models.length
  };
}

/**
 * Phase 2: Supervisor AI reviews all findings and resolves conflicts
 */
async function runSupervisorReview(analysisResults, sourceCode, contractName) {
  console.log('🧠 Starting supervisor review and conflict resolution...');
  
  // Prepare supervisor prompt with all findings
  const supervisorPrompt = createSupervisorPrompt(analysisResults, contractName);
  
  // Use most reliable model for supervisor role
  const supervisorModel = 'deepseek/deepseek-chat-v3-0324:free';
  
  try {
    const supervisorResult = await callOpenRouterAPI({
      model: supervisorModel,
      prompt: supervisorPrompt,
      sourceCode: sourceCode.substring(0, 8000), // Shorter version for supervisor
      contractName: contractName,
      maxTokens: 4000,
      temperature: 0.05 // Very low temperature for consistency
    });
    
    console.log('✅ Supervisor review completed successfully');
    
    return {
      supervisorModel: supervisorModel,
      supervisorAnalysis: supervisorResult,
      consensusScore: calculateConsensusScore(analysisResults.successfulResults),
      conflictsResolved: identifyAndResolveConflicts(analysisResults.successfulResults),
      success: true
    };
    
  } catch (error) {
    console.error('❌ Supervisor review failed:', error);
    
    // Fallback: manual consolidation without supervisor
    return {
      supervisorModel: 'manual-consolidation',
      supervisorAnalysis: createManualConsolidation(analysisResults.successfulResults),
      consensusScore: calculateConsensusScore(analysisResults.successfulResults),
      conflictsResolved: [],
      success: false,
      fallback: true
    };
  }
}

/**
 * Phase 3: Generate final comprehensive report
 */
function generateFinalReport(analysisResults, supervisorResult, contractName) {
  const successfulResults = analysisResults.successfulResults;
  const supervisorAnalysis = supervisorResult.supervisorAnalysis;
  
  // Aggregate all findings
  const allFindings = [];
  const allOptimizations = [];
  const allQualityIssues = [];
  
  // Collect findings from all models
  successfulResults.forEach(modelResult => {
    if (modelResult.result && !modelResult.result.error) {
      const analysis = modelResult.result;
      
      // Add findings with model attribution
      if (analysis.keyFindings && Array.isArray(analysis.keyFindings)) {
        analysis.keyFindings.forEach(finding => {
          allFindings.push({
            ...finding,
            reportedBy: modelResult.modelName,
            specialty: modelResult.specialty,
            confidence: calculateFindingConfidence(finding, successfulResults)
          });
        });
      }
      
      // Collect optimizations and quality issues
      if (analysis.gasOptimizations) {
        allOptimizations.push(...(analysis.gasOptimizations || []).map(opt => ({
          ...opt,
          reportedBy: modelResult.modelName
        })));
      }
      
      if (analysis.codeQualityIssues) {
        allQualityIssues.push(...(analysis.codeQualityIssues || []).map(issue => ({
          ...issue,
          reportedBy: modelResult.modelName
        })));
      }
    }
  });
  
  // Apply supervisor filtering and prioritization
  const prioritizedFindings = prioritizeFindingsBySupervisor(allFindings, supervisorAnalysis);
  const verifiedOptimizations = verifyOptimizations(allOptimizations, supervisorAnalysis);
  
  // Calculate final scores
  const securityScore = calculateWeightedSecurityScore(successfulResults, supervisorResult);
  const gasScore = calculateGasOptimizationScore(allOptimizations);
  const qualityScore = calculateCodeQualityScore(allQualityIssues);
  const overallScore = Math.round((securityScore * 0.6 + gasScore * 0.2 + qualityScore * 0.2));
  
  // Determine risk level
  const riskLevel = determineRiskLevel(securityScore, prioritizedFindings);
  
  return {
    overview: `Supervised multi-AI analysis completed for ${contractName}. ${successfulResults.length} AI models analyzed the contract with supervisor verification.`,
    contractType: supervisorAnalysis.contractType || detectContractType(contractName),
    
    // Scores
    securityScore: securityScore,
    gasOptimizationScore: gasScore,
    codeQualityScore: qualityScore,
    overallScore: overallScore,
    riskLevel: riskLevel,
    
    // Findings (supervisor-verified and prioritized)
    keyFindings: prioritizedFindings.slice(0, 15), // Top 15 most important
    allFindings: prioritizedFindings,
    gasOptimizations: verifiedOptimizations,
    codeQualityIssues: allQualityIssues,
    
    // Analysis metadata
    findingCounts: {
      critical: prioritizedFindings.filter(f => f.severity === 'CRITICAL').length,
      high: prioritizedFindings.filter(f => f.severity === 'HIGH').length,
      medium: prioritizedFindings.filter(f => f.severity === 'MEDIUM').length,
      low: prioritizedFindings.filter(f => f.severity === 'LOW').length,
      total: prioritizedFindings.length
    },
    
    // Consensus and verification info
    modelConsensus: {
      agreementRate: supervisorResult.consensusScore,
      conflictsResolved: supervisorResult.conflictsResolved.length,
      modelsUsed: successfulResults.length,
      specialties: successfulResults.map(r => r.specialty)
    },
    
    supervisorInsights: extractSupervisorInsights(supervisorAnalysis),
    
    summary: `Comprehensive supervised analysis revealed ${prioritizedFindings.filter(f => ['CRITICAL', 'HIGH'].includes(f.severity)).length} high-priority security issues. Overall security score: ${securityScore}/100 (${riskLevel}).`
  };
}

/**
 * Get specialized prompts for different AI model roles
 */
function getSpecializedPrompt(specialty) {
  const baseInstruction = `You are an expert smart contract auditor. Return ONLY valid JSON in this format:

{
  "overview": "Brief analysis",
  "contractType": "DeFi Protocol|Token|DEX|Lending|Other",
  "securityScore": 85,
  "gasOptimizationScore": 78,
  "codeQualityScore": 92,
  "riskLevel": "Safe|Low Risk|Medium Risk|High Risk",
  "keyFindings": [
    {
      "severity": "CRITICAL|HIGH|MEDIUM|LOW|INFO",
      "title": "Finding title",
      "description": "Detailed description",
      "recommendation": "How to fix",
      "confidence": "HIGH|MEDIUM|LOW"
    }
  ],
  "gasOptimizations": [],
  "codeQualityIssues": [],
  "summary": "Overall assessment"
}`;

  const specializations = {
    security: `${baseInstruction}

FOCUS ON SECURITY VULNERABILITIES:
- Reentrancy attacks (classic, cross-function, read-only)
- Access control vulnerabilities
- Integer overflow/underflow
- Flash loan attacks
- Oracle manipulation
- Front-running and MEV risks
- Unchecked external calls
- Dangerous delegatecall usage
- Signature replay attacks
- Be especially vigilant for fund theft mechanisms and rug pull patterns.`,

    gas: `${baseInstruction}

FOCUS ON GAS OPTIMIZATION:
- Expensive operations in loops
- Redundant storage reads/writes
- Inefficient data structures
- Unnecessary external calls
- Suboptimal function visibility
- Storage vs memory usage
- Packing struct variables
- Using events vs storage for data
- Assembly optimizations where appropriate.`,

    quality: `${baseInstruction}

FOCUS ON CODE QUALITY:
- Documentation quality
- Naming conventions
- Code organization and modularity
- Error handling practices
- Input validation
- Event emission patterns
- Interface compliance
- Testing coverage implications
- Maintainability issues.`,

    defi: `${baseInstruction}

FOCUS ON DeFi-SPECIFIC RISKS:
- Liquidity pool manipulation
- Slippage protection
- Price oracle reliability
- Token standard compliance (ERC-20, ERC-721, etc.)
- Yield farming vulnerabilities
- Governance attack vectors
- Cross-chain bridge risks
- MEV extraction opportunities
- Economic attacks and tokenomics flaws.`
  };

  return specializations[specialty] || specializations.security;
}

/**
 * Create supervisor prompt that reviews all model findings
 */
function createSupervisorPrompt(analysisResults, contractName) {
  const findings = analysisResults.successfulResults.map(result => ({
    model: result.modelName,
    specialty: result.specialty,
    findings: result.result.keyFindings || [],
    securityScore: result.result.securityScore || 0
  }));

  return `You are a senior smart contract security supervisor reviewing findings from multiple AI auditors.

CONTRACT: ${contractName}

TASK: Review all findings below, resolve conflicts, verify accuracy, and provide a consolidated assessment.

FINDINGS FROM SPECIALIST AI MODELS:
${JSON.stringify(findings, null, 2)}

SUPERVISOR INSTRUCTIONS:
1. Identify consensus findings (reported by multiple models)
2. Flag conflicting assessments 
3. Verify technical accuracy of each finding
4. Prioritize findings by actual risk level
5. Remove false positives or duplicate findings
6. Calculate accurate final security score

Return ONLY valid JSON with your consolidated analysis:

{
  "overview": "Supervisor assessment",
  "contractType": "DeFi Protocol|Token|DEX|Lending|Other",
  "securityScore": 85,
  "riskLevel": "Safe|Low Risk|Medium Risk|High Risk",
  "consolidatedFindings": [
    {
      "severity": "CRITICAL|HIGH|MEDIUM|LOW|INFO",
      "title": "Verified finding title",
      "description": "Supervisor-verified description",
      "recommendation": "Verified fix recommendation",
      "consensus": true/false,
      "reportedByCount": 2,
      "supervisorVerified": true,
      "technicalAccuracy": "HIGH|MEDIUM|LOW"
    }
  ],
  "conflictsResolved": [
    {
      "issue": "Description of conflict",
      "resolution": "How it was resolved",
      "finalAssessment": "Final decision"
    }
  ],
  "summary": "Supervisor summary with final risk assessment"
}`;
}

/**
 * Helper functions
 */
function calculateConsensusScore(results) {
  // Implementation for consensus calculation
  return 0.85; // Placeholder
}

function identifyAndResolveConflicts(results) {
  // Implementation for conflict resolution
  return []; // Placeholder
}

function calculateFindingConfidence(finding, allResults) {
  // Calculate how many models found similar issues
  return 'HIGH'; // Placeholder
}

function prioritizeFindingsBySupervisor(findings, supervisorAnalysis) {
  // Prioritize based on supervisor verification
  return findings.sort((a, b) => {
    const severityOrder = { 'CRITICAL': 4, 'HIGH': 3, 'MEDIUM': 2, 'LOW': 1, 'INFO': 0 };
    return severityOrder[b.severity] - severityOrder[a.severity];
  });
}

function verifyOptimizations(optimizations, supervisorAnalysis) {
  return optimizations; // Placeholder
}

function calculateWeightedSecurityScore(results, supervisorResult) {
  const scores = results.map(r => r.result.securityScore || 0).filter(s => s > 0);
  return scores.length > 0 ? Math.round(scores.reduce((a, b) => a + b) / scores.length) : 75;
}

function calculateGasOptimizationScore(optimizations) {
  return optimizations.length > 0 ? Math.max(60, 90 - optimizations.length * 5) : 85;
}

function calculateCodeQualityScore(qualityIssues) {
  return qualityIssues.length > 0 ? Math.max(60, 95 - qualityIssues.length * 3) : 90;
}

function determineRiskLevel(securityScore, findings) {
  const criticalCount = findings.filter(f => f.severity === 'CRITICAL').length;
  const highCount = findings.filter(f => f.severity === 'HIGH').length;
  
  if (criticalCount > 0) return 'High Risk';
  if (highCount > 1 || securityScore < 60) return 'Medium Risk';
  if (securityScore >= 85) return 'Safe';
  return 'Low Risk';
}

function detectContractType(contractName) {
  const name = contractName.toLowerCase();
  if (name.includes('token') || name.includes('erc20')) return 'Token';
  if (name.includes('swap') || name.includes('dex')) return 'DEX';
  if (name.includes('lending') || name.includes('borrow')) return 'Lending';
  if (name.includes('staking') || name.includes('farm')) return 'Staking';
  return 'Smart Contract';
}

function extractSupervisorInsights(supervisorAnalysis) {
  return {
    keyInsights: supervisorAnalysis.summary || 'Supervisor analysis completed',
    conflictsResolved: supervisorAnalysis.conflictsResolved?.length || 0,
    verificationLevel: 'SUPERVISOR_VERIFIED'
  };
}

function createManualConsolidation(results) {
  return {
    overview: 'Manual consolidation fallback',
    securityScore: 75,
    riskLevel: 'Medium Risk',
    consolidatedFindings: [],
    summary: 'Supervisor unavailable - manual consolidation used'
  };
}